# 数据库索引-MySQL索引结构和性能

> 数据库索引可加快数据检索操作，但是我们也为这些好处付出了代价。 在本文中，我们将关注MySQL索引背后的结构。通过使用大型数据集来测试数据库性能，我会测试同一数据库的两个版本：一个具有索引，另一个没有。 这是我们关于数据库索引的系列文章的第二篇。第一篇请单击[此处](https://riiy.github.io/2019/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.html)。

## 索引使用什么数据结构？
    > MySQL支持几种不同的索引类型。最重要的是BTREE树和HASH。这些类型也是其他DBMS中最常见的类型。 
    
在我们开始描述索引类型之前，让我们快速回顾一下最常见树的节点类型：

1. 根节点 - 树结构中的最顶层节点 
2. 子节点 - 另一个节点（父节点）指向的节点 
3. 父节点 - 指向其他节点（子节点）的节点 
4. 叶节点 - 没有子节点的节点（位于树结构的底部） 
5. 内部节点 - 所有“非叶子”节点，包括根节点 
6. 外部节点 - 叶节点的另一个名称

### 二叉搜索树(BST)

![binary-search-tree](https://riiy.github.io/images/binary-search-tree.jpg)

上图是一个二叉搜索树（BST）结构，这些结构不是数据库索引使用的数据结构，但数据库使用的树结构（B-Tree和B + Tree）和BST相似的。 

BST是二叉树，其中节点被排序。在上图中，我们看到节点X左侧的值小于X，节点X右侧的值更大。这就是任何BST的组织方式。 

当我们在BST中搜索值时，我们从根节点开始，并将搜索到的值与根节点的值进行比较。如果搜索的值低于根值，我们将转到左子树。相反，则去右边的子树查找。如果我们找到了对应的值，完成查找 。如果到达叶节点而没有找到我们的值，就能知道所查找的值不在这个BST的树中。

向BST添加新值就像搜索值一样。 （一旦我们为我们的值找到合适的位置，当然，过程会发生变化。）例如，如果我们要添加值“30”，我们会将其添加为节点“31”的左子节点（30）大于27，所以我们向右走; 30小于35，所以我们向左走; 30小于31，所以我们再向左走。） 

当想要从BST中删除一个值时，情况就更复杂了。在某些情况下，甚至可能需要重新排列树。有三种可能的情况：

1. 删除没有子节点的节点 - 我们只需从BST中删除该节点。在我们的例子中，这些是节点“10”，“19”，“31”和“42”。 
2. 删除具有一个子节点的节点 - 我们将用子节点替换已删除的节点。如果节点“31”在左子树中具有“30”作为子节点并且我们将其删除，则我们将简单地将“31”替换为“30”。 
3. 删除具有两个子节点的节点 - 这是最复杂的情​​况。在这种情况下，我们将找到已删除节点的右子树中的最小元素，并将其放在已删除节点的位置。因此，如果我们删除节点“27”，我们将在右侧子树中查找最小值，即“31”。我们将节点“27”替换为节点“31”。

### B-Tree

![B-Tree](https://riiy.github.io/images/b-tree.png)
